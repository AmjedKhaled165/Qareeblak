import { INetworkModule, Logger } from "@azure/msal-common/node";
import { ManagedIdentityRequestParameters } from "../../config/ManagedIdentityRequestParameters.js";
import { BaseManagedIdentitySource } from "./BaseManagedIdentitySource.js";
import { NodeStorage } from "../../cache/NodeStorage.js";
import { CryptoProvider } from "../../crypto/CryptoProvider.js";
import { ManagedIdentityId } from "../../config/ManagedIdentityId.js";
/**
 * Azure Cloud Shell managed identity source implementation.
 *
 * This class handles authentication for applications running in Azure Cloud Shell environment.
 * Cloud Shell provides a browser-accessible shell for managing Azure resources and includes
 * a pre-configured managed identity for authentication.
 *
 * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/CloudShellManagedIdentitySource.cs
 */
export declare class CloudShell extends BaseManagedIdentitySource {
    private msiEndpoint;
    /**
     * Creates a new CloudShell managed identity source instance.
     *
     * @param logger - Logger instance for diagnostic logging
     * @param nodeStorage - Node.js storage implementation for caching
     * @param networkClient - HTTP client for making requests to the managed identity endpoint
     * @param cryptoProvider - Cryptographic operations provider
     * @param disableInternalRetries - Whether to disable automatic retry logic for failed requests
     * @param msiEndpoint - The MSI endpoint URL obtained from environment variables
     */
    constructor(logger: Logger, nodeStorage: NodeStorage, networkClient: INetworkModule, cryptoProvider: CryptoProvider, disableInternalRetries: boolean, msiEndpoint: string);
    /**
     * Retrieves the required environment variables for Cloud Shell managed identity.
     *
     * Cloud Shell requires the MSI_ENDPOINT environment variable to be set, which
     * contains the URL of the managed identity service endpoint.
     *
     * @returns An array containing the MSI_ENDPOINT environment variable value (or undefined if not set)
     */
    static getEnvironmentVariables(): Array<string | undefined>;
    /**
     * Attempts to create a CloudShell managed identity source instance.
     *
     * This method validates that the required environment variables are present and
     * creates a CloudShell instance if the environment is properly configured.
     * Cloud Shell only supports system-assigned managed identities.
     *
     * @param logger - Logger instance for diagnostic logging
     * @param nodeStorage - Node.js storage implementation for caching
     * @param networkClient - HTTP client for making requests
     * @param cryptoProvider - Cryptographic operations provider
     * @param disableInternalRetries - Whether to disable automatic retry logic
     * @param managedIdentityId - The managed identity configuration (must be system-assigned)
     *
     * @returns A CloudShell instance if the environment is valid, null otherwise
     *
     * @throws {ManagedIdentityError} When a user-assigned managed identity is requested,
     *         as Cloud Shell only supports system-assigned identities
     */
    static tryCreate(logger: Logger, nodeStorage: NodeStorage, networkClient: INetworkModule, cryptoProvider: CryptoProvider, disableInternalRetries: boolean, managedIdentityId: ManagedIdentityId): CloudShell | null;
    /**
     * Creates an HTTP request to acquire an access token from the Cloud Shell managed identity endpoint.
     *
     * This method constructs a POST request to the MSI endpoint with the required headers and
     * body parameters for Cloud Shell authentication. The request includes the target resource
     * for which the access token is being requested.
     *
     * @param resource - The target resource/scope for which to request an access token (e.g., "https://graph.microsoft.com/.default")
     *
     * @returns A configured ManagedIdentityRequestParameters object ready for network execution
     */
    createRequest(resource: string): ManagedIdentityRequestParameters;
}
//# sourceMappingURL=CloudShell.d.ts.mapAM,UAAU,GAAG,YAAY,CAAC,YAAY,EAAE,CAAC;gBAE/C,kDAAkD;gBAClD,MAAM,oBAAoB,GACxB,UAAU,CAAC,IAAI,KAAK,qCAAc,CAAC,eAAe;oBAClD,UAAU,CAAC,IAAI,KAAK,qCAAc,CAAC,gBAAgB;oBACnD,UAAU,CAAC,IAAI,KAAK,qCAAc,CAAC,0BAA0B,CAAC;gBAEhE,OAAO;oBACL,UAAU;oBACV,SAAS,EAAE,YAAY,CAAC,SAAS;oBACjC,OAAO;oBACP,KAAK,EAAE;wBACL,GAAG,EAAE,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,SAAS;wBACtD,GAAG,EAAE,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,SAAS;wBACtD,GAAG,EAAE,CAAC,oBAAoB,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,SAAS;wBACvD,OAAO,EAAE,UAAU,CAAC,OAAO;wBAC3B,KAAK,EAAE,UAAU,CAAC,KAAK;qBACxB;iBACF,CAAC;YACJ,CAAC,CAAC;SACH,CAAC;IACJ,CAAC;CACF;AAlJD,kDAkJC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n} from './types';\nimport { DataPointType, HistogramMetricData } from '../export/MetricData';\nimport { HrTime } from '@opentelemetry/api';\nimport { InstrumentDescriptor, InstrumentType } from '../InstrumentDescriptor';\nimport { binarySearchLB, Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\n\n/**\n * Internal value type for HistogramAggregation.\n * Differs from the exported type as undefined sum/min/max complicate arithmetic\n * performed by this aggregation, but are required to be undefined in the exported types.\n */\ninterface InternalHistogram {\n  buckets: {\n    boundaries: number[];\n    counts: number[];\n  };\n  sum: number;\n  count: number;\n  hasMinMax: boolean;\n  min: number;\n  max: number;\n}\n\nfunction createNewEmptyCheckpoint(boundaries: number[]): InternalHistogram {\n  const counts = boundaries.map(() => 0);\n  counts.push(0);\n  return {\n    buckets: {\n      boundaries,\n      counts,\n    },\n    sum: 0,\n    count: 0,\n    hasMinMax: false,\n    min: Infinity,\n    max: -Infinity,\n  };\n}\n\nexport class HistogramAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    private readonly _boundaries: number[],\n    private _recordMinMax = true,\n    private _current: InternalHistogram = createNewEmptyCheckpoint(_boundaries)\n  ) {}\n\n  record(value: number): void {\n    this._current.count += 1;\n    this._current.sum += value;\n\n    if (this._recordMinMax) {\n      this._current.min = Math.min(value, this._current.min);\n      this._current.max = Math.max(value, this._current.max);\n      this._current.hasMinMax = true;\n    }\n\n    const idx = binarySearchLB(this._boundaries, value);\n    this._current.buckets.counts[idx + 1] += 1;\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): InternalHistogram {\n    return this._current;\n  }\n}\n\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nexport class HistogramAggregator implements Aggregator<HistogramAccumulation> {\n  public kind: AggregatorKind.HISTOGRAM = AggregatorKind.HISTOGRAM;\n\n  /**\n   * @param _boundaries sorted upper bounds of recorded values.\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    private readonly _boundaries: number[],\n    private readonly _recordMinMax: boolean\n  ) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new HistogramAccumulation(\n      startTime,\n      this._boundaries,\n      this._recordMinMax\n    );\n  }\n\n  /**\n   * Return the result of the merge of two histogram accumulations. As long as one Aggregator\n   * instance produces all Accumulations with constant boundaries we don't need to worry about\n   * merging accumulations with different boundaries.\n   */\n  merge(\n    previous: HistogramAccumulation,\n    delta: HistogramAccumulation\n  ): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const deltaValue = delta.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const deltaCounts = deltaValue.buckets.counts;\n\n    const mergedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];\n    }\n\n    let min = Infinity;\n    let max = -Infinity;\n\n    if (this._recordMinMax) {\n      if (previousValue.hasMinMax && deltaValue.hasMinMax) {\n        min = Math.min(previousValue.min, deltaValue.min);\n        max = Math.max(previousValue.max, deltaValue.max);\n      } else if (previousValue.hasMinMax) {\n        min = previousValue.min;\n        max = previousValue.max;\n      } else if (deltaValue.hasMinMax) {\n        min = deltaValue.min;\n        max = deltaValue.max;\n      }\n    }\n\n    return new HistogramAccumulation(\n      previous.startTime,\n      previousValue.buckets.boundaries,\n      this._recordMinMax,\n      {\n        buckets: {\n          boundaries: previousValue.buckets.boundaries,\n          counts: mergedCounts,\n        },\n        count: previousValue.count + deltaValue.count,\n        sum: previousValue.sum + deltaValue.sum,\n        hasMinMax:\n          this._recordMinMax &&\n          (previousValue.hasMinMax || deltaValue.hasMinMax),\n        min: min,\n        max: max,\n      }\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(\n    previous: HistogramAccumulation,\n    current: HistogramAccumulation\n  ): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const currentValue = current.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const currentCounts = currentValue.buckets.counts;\n\n    const diffedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];\n    }\n\n    return new HistogramAccumulation(\n      current.startTime,\n      previousValue.buckets.boundaries,\n      this._recordMinMax,\n      {\n        buckets: {\n          boundaries: previousValue.buckets.boundaries,\n          counts: diffedCounts,\n        },\n        count: currentValue.count - previousValue.count,\n        sum: currentValue.sum - previousValue.sum,\n        hasMinMax: false,\n        min: Infinity,\n        max: -Infinity,\n      }\n    );\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<HistogramAccumulation>[],\n    endTime: HrTime\n  ): Maybe<HistogramMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        const pointValue = accumulation.toPointValue();\n\n        // determine if instrument allows negative values.\n        const allowsNegativeValues =\n          descriptor.type === InstrumentType.UP_DOWN_COUNTER ||\n          descriptor.type === InstrumentType.OBSERVABLE_GAUGE ||\n          descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            buckets: pointValue.buckets,\n            count: pointValue.count,\n          },\n        };\n      }),\n    };\n  }\n}\n"]}